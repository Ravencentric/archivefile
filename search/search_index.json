{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p>     Unified interface for tar, zip, sevenzip, and rar files   </p> </p> <p> </p> <p> </p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ul> <li>About</li> <li>Installation</li> <li>Usage</li> <li>License</li> </ul>"},{"location":"#about","title":"About","text":"<p><code>archivefile</code> is a wrapper around <code>tarfile</code>, <code>zipfile</code>, <code>py7zr</code>, and <code>rarfile</code>.</p> <p>The above libraries are excellent when you are dealing with a single archive format but things quickly get annoying when you have a bunch of mixed archives such as <code>.zip</code>, <code>.7z</code>, <code>.cbr</code>, <code>.tar.gz</code>, etc because each library has a slightly different syntax and quirks which you need to deal with.</p> <p><code>archivefile</code> wraps the common methods from the above libraries to provide a unified interface that takes care of said differences under the hood. However, it's not as powerful as the libraries it wraps due to lack of support for features that are unique to a specific archive format and library.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>archivefile</code> is available on PyPI, so you can simply use pip to install it.</p> <ol> <li> <p>Without optional dependencies:</p> <pre><code>pip install archivefile\n</code></pre> </li> <li> <p>With optional dependencies:</p> <ul> <li> <p>Required for <code>ArchiveFile.print_tree()</code></p> <pre><code>pip install archivefile[bigtree]\n</code></pre> </li> <li> <p>Required for <code>ArchiveFile.print_table()</code></p> <pre><code>pip install archivefile[rich]\n</code></pre> </li> </ul> </li> <li> <p>With all dependencies:</p> <pre><code>pip install archivefile[all]\n</code></pre> </li> </ol>"},{"location":"#usage","title":"Usage","text":"<p><code>archivefile</code> offers a single class called <code>ArchiveFile</code> to deal with various archive formats. Some examples are given below:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"../source.zip\") as archive:\n    archive.extract(\"pyproject.toml\", destination=\"./dest/\") # Extract a single member by it's name\n    archive.extractall(destination=\"./dest/\") # Extract all members\n    archive.get_member(\"pyproject.toml\")  # Get the ArchiveMember object for the member by it's name\n    archive.get_members()  # Retrieve all members from the archive as a generator of ArchiveMember objects\n    archive.get_names()  # Retrieve names of all members in the archive as a tuple of strings\n    archive.read_bytes(\"pyproject.toml\") # Read the contents of the member as bytes\n    archive.read_text(\"pyproject.toml\")  # Read the contents of the member as text\n    archive.print_tree()  # Print the contents of the archive as a tree.\n    archive.print_table()  # Print the contents of the archive as a table.\n\nwith ArchiveFile(\"../source.zip\", \"w\") as archive:\n    archive.write(\"foo.txt\", arcname=\"bar.txt\")  # Write foo.txt to the archive as bar.txt\n    archive.writeall(\"./src/\") # Recursively write the ./src/ directory to the archive\n    archive.write_text(\"spam and eggs\", arcname=\"recipe.txt\") # Write a string to the archive as recipe.txt\n    archive.write_bytes(b\"0101001010100101\", arcname=\"terminator.py\")  # Write bytes to the archive as terminator.py\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Distributed under the Unlicense License. See UNLICENSE for more information.</p>"},{"location":"api-reference/archivefile/","title":"ArchiveFile","text":""},{"location":"api-reference/archivefile/#archivefile.ArchiveFile","title":"ArchiveFile","text":"<pre><code>ArchiveFile(file: StrPath, mode: OpenArchiveMode | str = 'r', *, password: str | None = None, compression_type: CompressionType | None = None, compression_level: CompressionLevel | int | None = None, **kwargs: Any)\n</code></pre> <p>               Bases: <code>BaseArchiveAdapter</code></p> <p>Open an archive file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>StrPath</code> <p>Path to the archive file.</p> required <code>mode</code> <code>OpenArchiveMode</code> <p>Mode for opening the archive file.</p> <code>'r'</code> <code>password</code> <code>str</code> <p>Password for encrypted archive files.</p> <code>None</code> <code>compression_type</code> <code>CompressionType</code> <p>The compression method for writing zip files.</p> <code>None</code> <code>compression_level</code> <code>CompressionLevel</code> <p>The compression level for writing zip files.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Keyword arugments to pass to the underlying library.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Raised if the archive format is unsupported</p> Notes <p>The <code>compression_type</code> and <code>compression_level</code> parameters are only applicable when creating zip files and do not affect reading zip files or other archive formats.</p> References <p>ArchiveFile currently supports the following:</p> <ul> <li><code>ZipFile</code></li> <li><code>TarFile</code></li> <li><code>RarFile</code></li> <li><code>SevenZipFile</code></li> </ul> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef __init__(\n    self,\n    file: StrPath,\n    mode: OpenArchiveMode | str = \"r\",\n    *,\n    password: str | None = None,\n    compression_type: CompressionType | None = None,\n    compression_level: CompressionLevel | int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Open an archive file.\n\n    Parameters\n    ----------\n    file : StrPath\n        Path to the archive file.\n    mode : OpenArchiveMode, optional\n        Mode for opening the archive file.\n    password : str, optional\n        Password for encrypted archive files.\n    compression_type : CompressionType, optional\n        The compression method for writing zip files.\n    compression_level : CompressionLevel, optional\n        The compression level for writing zip files.\n    kwargs : Any\n        Keyword arugments to pass to the underlying library.\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    NotImplementedError\n        Raised if the archive format is unsupported\n\n    Notes\n    -----\n    The `compression_type` and `compression_level` parameters are only applicable when creating\n    zip files and do not affect reading zip files or other archive formats.\n\n    References\n    ----------\n    ArchiveFile currently supports the following:\n\n    - [`ZipFile`][zipfile.ZipFile]\n    - [`TarFile`][tarfile.TarFile.open]\n    - [`RarFile`][rarfile.RarFile]\n    - [`SevenZipFile`][py7zr.SevenZipFile]\n    \"\"\"\n    self._file = realpath(file)\n    self._mode = mode\n    self._password = password\n    self._kwargs = kwargs\n    self._compression_type = compression_type\n    self._compression_level = compression_level\n    self._initialize_adapter()\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.adapter","title":"adapter  <code>property</code>","text":"<pre><code>adapter: str\n</code></pre> <p>Name of the underlying adapter class, useful for debugging.</p>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.compression_level","title":"compression_level  <code>property</code>","text":"<pre><code>compression_level: CompressionLevel | None\n</code></pre> <p>Compression level used for writing.</p>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.compression_type","title":"compression_type  <code>property</code>","text":"<pre><code>compression_type: CompressionType | None\n</code></pre> <p>Compression type used for writing.</p>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.file","title":"file  <code>property</code>","text":"<pre><code>file: Path\n</code></pre> <p>Path to the archive file.</p>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.mode","title":"mode  <code>property</code>","text":"<pre><code>mode: OpenArchiveMode\n</code></pre> <p>Mode in which the archive file was opened.</p>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.password","title":"password  <code>property</code>","text":"<pre><code>password: str | None\n</code></pre> <p>Archive password.</p>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the archive file.</p> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\narchive = ArchiveFile(\"skynet.zip\", \"w\")\narchive.write_bytes(b\"01010101001\", arcname=\"terminator.py\")\narchive.close()\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Close the archive file.\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    archive = ArchiveFile(\"skynet.zip\", \"w\")\n    archive.write_bytes(b\"01010101001\", arcname=\"terminator.py\")\n    archive.close()\n    ```\n    \"\"\"\n    self._adapter.close()\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.extract","title":"extract","text":"<pre><code>extract(member: StrPath | ArchiveMember, *, destination: StrPath = Path.cwd()) -&gt; Path\n</code></pre> <p>Extract a member of the archive.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>StrPath | ArchiveMember</code> <p>Name of the member or an ArchiveMember object.</p> required <code>destination</code> <code>StrPath</code> <p>The path to the directory where the member will be extracted. If not specified, the current working directory is used as the default destination.</p> <code>cwd()</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the extracted file.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>Raised if the member is not found in the archive.</p> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.zip\") as archive:\n    file = archive.extract(\"hello-world/pyproject.toml\")\n    print(file.read_text())\n    # [tool.poetry]\n    # name = \"hello-world\"\n    # version = \"0.1.0\"\n    # description = \"\"\n    # readme = \"README.md\"\n    # packages = [{include = \"hello_world\", from = \"src\"}]\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef extract(self, member: StrPath | ArchiveMember, *, destination: StrPath = Path.cwd()) -&gt; Path:\n    \"\"\"\n    Extract a member of the archive.\n\n    Parameters\n    ----------\n    member : StrPath | ArchiveMember\n        Name of the member or an ArchiveMember object.\n    destination : StrPath\n        The path to the directory where the member will be extracted.\n        If not specified, the current working directory is used as the default destination.\n\n    Returns\n    -------\n    Path\n        The path to the extracted file.\n\n    Raises\n    ------\n    KeyError\n        Raised if the member is not found in the archive.\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.zip\") as archive:\n        file = archive.extract(\"hello-world/pyproject.toml\")\n        print(file.read_text())\n        # [tool.poetry]\n        # name = \"hello-world\"\n        # version = \"0.1.0\"\n        # description = \"\"\n        # readme = \"README.md\"\n        # packages = [{include = \"hello_world\", from = \"src\"}]\n    ```\n    \"\"\"\n    return self._adapter.extract(member, destination=destination)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.extractall","title":"extractall","text":"<pre><code>extractall(*, destination: StrPath = Path.cwd(), members: CollectionOf[StrPath | ArchiveMember] | None = None) -&gt; Path\n</code></pre> <p>Extract all the members of the archive to the destination directory.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>StrPath</code> <p>The path to the directory where the members will be extracted. If not specified, the current working directory is used as the default destination.</p> <code>cwd()</code> <code>members</code> <code>CollectionOf[StrPath | ArchiveMember]</code> <p>Collection of member names or ArchiveMember objects to extract. Default is <code>None</code> which will extract all members.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the destination directory.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>Raised if any member in members was not found in the archive.</p> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.zip\") as archive:\n    outdir = archive.extractall()\n\nfor file in outdir.rglob(\"*\"):\n    print(file)\n    # /source/hello-world\n    # /source/hello-world/pyproject.toml\n    # /source/hello-world/README.md\n    # /source/hello-world/src\n    # /source/hello-world/tests\n    # /source/hello-world/src/hello_world\n    # /source/hello-world/src/hello_world/__init__.py\n    # /source/hello-world/tests/__init__.py\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef extractall(\n    self, *, destination: StrPath = Path.cwd(), members: CollectionOf[StrPath | ArchiveMember] | None = None\n) -&gt; Path:\n    \"\"\"\n    Extract all the members of the archive to the destination directory.\n\n    Parameters\n    ----------\n    destination : StrPath\n        The path to the directory where the members will be extracted.\n        If not specified, the current working directory is used as the default destination.\n    members : CollectionOf[StrPath | ArchiveMember], optional\n        Collection of member names or ArchiveMember objects to extract.\n        Default is `None` which will extract all members.\n\n    Returns\n    -------\n    Path\n        The path to the destination directory.\n\n    Raises\n    ------\n    KeyError\n        Raised if any member in members was not found in the archive.\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.zip\") as archive:\n        outdir = archive.extractall()\n\n    for file in outdir.rglob(\"*\"):\n        print(file)\n        # /source/hello-world\n        # /source/hello-world/pyproject.toml\n        # /source/hello-world/README.md\n        # /source/hello-world/src\n        # /source/hello-world/tests\n        # /source/hello-world/src/hello_world\n        # /source/hello-world/src/hello_world/__init__.py\n        # /source/hello-world/tests/__init__.py\n    ```\n    \"\"\"\n    return self._adapter.extractall(destination=destination, members=members)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.get_member","title":"get_member","text":"<pre><code>get_member(member: StrPath | ArchiveMember) -&gt; ArchiveMember\n</code></pre> <p>Retrieve an ArchiveMember object by it's name.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>StrPath | ArchiveMember</code> <p>Name of the member.</p> required <p>Returns:</p> Type Description <code>ArchiveMember</code> <p>Represents a member of the archive.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>Raised if the member is not found in the archive.</p> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.tar\") as archive:\n    archive.get_member(\"README.md\")\n    # ArchiveMember(name='README.md', size=3799, compressed_size=3799, datetime=datetime.datetime(2024, 4, 10, 20, 10, 57, tzinfo=datetime.timezone.utc), checksum=5251, is_dir=False, is_file=True)\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef get_member(self, member: StrPath | ArchiveMember) -&gt; ArchiveMember:\n    \"\"\"\n    Retrieve an ArchiveMember object by it's name.\n\n    Parameters\n    ----------\n    member : StrPath | ArchiveMember\n        Name of the member.\n\n    Returns\n    -------\n    ArchiveMember\n        Represents a member of the archive.\n\n    Raises\n    ------\n    KeyError\n        Raised if the member is not found in the archive.\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.tar\") as archive:\n        archive.get_member(\"README.md\")\n        # ArchiveMember(name='README.md', size=3799, compressed_size=3799, datetime=datetime.datetime(2024, 4, 10, 20, 10, 57, tzinfo=datetime.timezone.utc), checksum=5251, is_dir=False, is_file=True)\n    ```\n    \"\"\"\n    return self._adapter.get_member(member)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.get_members","title":"get_members","text":"<pre><code>get_members() -&gt; Generator[ArchiveMember]\n</code></pre> <p>Retrieve all members of the archive as a generator of <code>ArchiveMember</code> objects.</p> <p>Yields:</p> Type Description <code>ArchiveMember</code> <p>Each member of the archive as an <code>ArchiveMember</code> object.</p> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.tar\") as archive:\n    for member in archive.get_members():\n        print(member.name)\n        # project/pyproject.toml\n        # project/src\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef get_members(self) -&gt; Generator[ArchiveMember]:\n    \"\"\"\n    Retrieve all members of the archive as a generator of `ArchiveMember` objects.\n\n    Yields\n    -------\n    ArchiveMember\n        Each member of the archive as an `ArchiveMember` object.\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.tar\") as archive:\n        for member in archive.get_members():\n            print(member.name)\n            # project/pyproject.toml\n            # project/src\n    ```\n    \"\"\"\n    yield from self._adapter.get_members()\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.get_names","title":"get_names","text":"<pre><code>get_names() -&gt; tuple[str, ...]\n</code></pre> <p>Retrieve all members of the archive as a tuple of strings.</p> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>Members of the archive as a tuple of strings.</p> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.tar\") as archive:\n    archive.get_names()\n    # (\n    #     \"project/pyproject.toml\",\n    #     \"project/src\",\n    # )\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef get_names(self) -&gt; tuple[str, ...]:\n    \"\"\"\n    Retrieve all members of the archive as a tuple of strings.\n\n    Returns\n    -------\n    tuple[str, ...]\n        Members of the archive as a tuple of strings.\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.tar\") as archive:\n        archive.get_names()\n        # (\n        #     \"project/pyproject.toml\",\n        #     \"project/src\",\n        # )\n    ```\n    \"\"\"\n    return self._adapter.get_names()\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.print_table","title":"print_table","text":"<pre><code>print_table(*, title: str | None = None, style: TableStyle = 'markdown', sort_by: SortBy = 'name', descending: bool = False, **kwargs: Any) -&gt; None\n</code></pre> <p>Print the contents of the archive as a table.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the table. Defaults to archive file name.</p> <code>None</code> <code>style</code> <code>TableStyle</code> <p>The style of the table.</p> <code>'markdown'</code> <code>sort_by</code> <code>SortBy</code> <p>Key used to sort the table.</p> <code>'name'</code> <code>descending</code> <code>bool</code> <p>If True, sorting will be in descending order.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the <code>Table</code> constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>The <code>rich</code> dependency is required to use this method.</p> <p>You can install it via either of these commands:</p> <ul> <li><code>pip install archivefile[rich]</code></li> <li><code>pip install archivefile[all]</code></li> </ul> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.zip\") as archive:\n    archive.print_table()\n    #                                                     source.zip\n    #\n    # | Name                                    | Date modified             | Type   | Size | Compressed Size |\n    # |-----------------------------------------|---------------------------|--------|------|-----------------|\n    # | hello-world/                            | 2024-05-02T09:41:24+00:00 | Folder | 0B   | 0B              |\n    # | hello-world/README.md                   | 2024-05-02T09:41:24+00:00 | File   | 0B   | 0B              |\n    # | hello-world/pyproject.toml              | 2024-05-02T09:41:24+00:00 | File   | 363B | 241B            |\n    # | hello-world/src/                        | 2024-05-02T09:41:24+00:00 | Folder | 0B   | 0B              |\n    # | hello-world/src/hello_world/            | 2024-05-02T09:41:24+00:00 | Folder | 0B   | 0B              |\n    # | hello-world/src/hello_world/__init__.py | 2024-05-02T09:41:24+00:00 | File   | 0B   | 0B              |\n    # | hello-world/tests/                      | 2024-05-02T09:41:24+00:00 | Folder | 0B   | 0B              |\n    # | hello-world/tests/__init__.py           | 2024-05-02T09:41:24+00:00 | File   | 0B   | 0B              |\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef print_table(\n    self,\n    *,\n    title: str | None = None,\n    style: TableStyle = \"markdown\",\n    sort_by: SortBy = \"name\",\n    descending: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Print the contents of the archive as a table.\n\n    Parameters\n    ----------\n    title : str, optional\n        Title of the table. Defaults to archive file name.\n    style : TableStyle, optional\n        The style of the table.\n    sort_by : SortBy, optional\n        Key used to sort the table.\n    descending : bool, optional\n        If True, sorting will be in descending order.\n    kwargs : Any\n        Additional keyword arguments to be passed to the [`Table`][rich.table.Table] constructor.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    The [`rich`](https://pypi.org/p/rich/) dependency is required to use this method.\n\n    You can install it via either of these commands:\n\n    - `pip install archivefile[rich]`\n    - `pip install archivefile[all]`\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.zip\") as archive:\n        archive.print_table()\n        #                                                     source.zip\n        #\n        # | Name                                    | Date modified             | Type   | Size | Compressed Size |\n        # |-----------------------------------------|---------------------------|--------|------|-----------------|\n        # | hello-world/                            | 2024-05-02T09:41:24+00:00 | Folder | 0B   | 0B              |\n        # | hello-world/README.md                   | 2024-05-02T09:41:24+00:00 | File   | 0B   | 0B              |\n        # | hello-world/pyproject.toml              | 2024-05-02T09:41:24+00:00 | File   | 363B | 241B            |\n        # | hello-world/src/                        | 2024-05-02T09:41:24+00:00 | Folder | 0B   | 0B              |\n        # | hello-world/src/hello_world/            | 2024-05-02T09:41:24+00:00 | Folder | 0B   | 0B              |\n        # | hello-world/src/hello_world/__init__.py | 2024-05-02T09:41:24+00:00 | File   | 0B   | 0B              |\n        # | hello-world/tests/                      | 2024-05-02T09:41:24+00:00 | Folder | 0B   | 0B              |\n        # | hello-world/tests/__init__.py           | 2024-05-02T09:41:24+00:00 | File   | 0B   | 0B              |\n    ```\n    \"\"\"\n    self._adapter.print_table(title=title, style=style, sort_by=sort_by, descending=descending, **kwargs)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.print_tree","title":"print_tree","text":"<pre><code>print_tree(*, max_depth: int = 0, style: TreeStyle = 'const') -&gt; None\n</code></pre> <p>Print the contents of the archive as a tree.</p> <p>Parameters:</p> Name Type Description Default <code>max_depth</code> <code>int</code> <p>Maximum depth to print.</p> <code>0</code> <code>style</code> <code>TreeStyle</code> <p>The style of the tree.</p> <code>'const'</code> <p>Returns:</p> Type Description <code>None</code> Notes <p>The <code>bigtree</code> dependency is required to use this method.</p> <p>You can install it via either of these commands:</p> <ul> <li><code>pip install archivefile[bigtree]</code></li> <li><code>pip install archivefile[all]</code></li> </ul> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.tar.gz\") as archive:\n    archive.print_tree()\n    # source.tar.gz\n    # \u2514\u2500\u2500 hello-world\n    #     \u251c\u2500\u2500 pyproject.toml\n    #     \u251c\u2500\u2500 README.md\n    #     \u251c\u2500\u2500 src\n    #     \u2502   \u2514\u2500\u2500 hello_world\n    #     \u2502       \u2514\u2500\u2500 __init__.py\n    #     \u2514\u2500\u2500 tests\n    #         \u2514\u2500\u2500 __init__.py\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>def print_tree(\n    self,\n    *,\n    max_depth: int = 0,\n    style: TreeStyle = \"const\",\n) -&gt; None:\n    \"\"\"\n    Print the contents of the archive as a tree.\n\n    Parameters\n    ----------\n    max_depth : int, optional\n        Maximum depth to print.\n    style : TreeStyle, optional\n        The style of the tree.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    The [`bigtree`](https://pypi.org/p/bigtree/) dependency is required to use this method.\n\n    You can install it via either of these commands:\n\n    - `pip install archivefile[bigtree]`\n    - `pip install archivefile[all]`\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.tar.gz\") as archive:\n        archive.print_tree()\n        # source.tar.gz\n        # \u2514\u2500\u2500 hello-world\n        #     \u251c\u2500\u2500 pyproject.toml\n        #     \u251c\u2500\u2500 README.md\n        #     \u251c\u2500\u2500 src\n        #     \u2502   \u2514\u2500\u2500 hello_world\n        #     \u2502       \u2514\u2500\u2500 __init__.py\n        #     \u2514\u2500\u2500 tests\n        #         \u2514\u2500\u2500 __init__.py\n    ```\n    \"\"\"\n    self._adapter.print_tree(max_depth=max_depth, style=style)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.read_bytes","title":"read_bytes","text":"<pre><code>read_bytes(member: StrPath | ArchiveMember) -&gt; bytes\n</code></pre> <p>Read the member in bytes mode.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>StrPath | ArchiveMember</code> <p>Name of the member or an ArchiveMember object.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The contents of the file as bytes.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>Raised if the member is not found in the archive.</p> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.zip\") as archive:\n    data = archive.read_bytes(\"hello-world/pyproject.toml\")\n    print(data)\n    # b'[tool.poetry]\\r\\nname = \"hello-world\"\\r\\nversion = \"0.1.0\"\\r\\ndescription = \"\"\\r\\nreadme = \"README.md\"\\r\\npackages = [{include = \"hello_world\", from = \"src\"}]\\r\\n'\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef read_bytes(self, member: StrPath | ArchiveMember) -&gt; bytes:\n    \"\"\"\n    Read the member in bytes mode.\n\n    Parameters\n    ----------\n    member : StrPath | ArchiveMember\n        Name of the member or an ArchiveMember object.\n\n    Returns\n    -------\n    bytes\n        The contents of the file as bytes.\n\n    Raises\n    ------\n    KeyError\n        Raised if the member is not found in the archive.\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.zip\") as archive:\n        data = archive.read_bytes(\"hello-world/pyproject.toml\")\n        print(data)\n        # b'[tool.poetry]\\\\r\\\\nname = \"hello-world\"\\\\r\\\\nversion = \"0.1.0\"\\\\r\\\\ndescription = \"\"\\\\r\\\\nreadme = \"README.md\"\\\\r\\\\npackages = [{include = \"hello_world\", from = \"src\"}]\\\\r\\\\n'\n    ```\n    \"\"\"\n    return self._adapter.read_bytes(member)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.read_text","title":"read_text","text":"<pre><code>read_text(member: StrPath | ArchiveMember, *, encoding: str = 'utf-8', errors: ErrorHandler = 'strict') -&gt; str\n</code></pre> <p>Read the member in text mode.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>StrPath | ArchiveMember</code> <p>Name of the member or an ArchiveMember object.</p> required <code>encoding</code> <code>str</code> <p>Encoding used to read the file. Default is <code>utf-8</code>.</p> <code>'utf-8'</code> <code>errors</code> <code>ErrorHandler</code> <p>String that specifies how encoding and decoding errors are to be handled.</p> <code>'strict'</code> <p>Returns:</p> Type Description <code>str</code> <p>The contents of the file as a string.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>Raised if the member is not found in the archive.</p> References <ul> <li>Standard Encodings</li> <li>Error Handlers</li> </ul> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.zip\") as archive:\n    text = archive.read_text(\"hello-world/pyproject.toml\")\n    print(text)\n    # [tool.poetry]\n    # name = \"hello-world\"\n    # version = \"0.1.0\"\n    # description = \"\"\n    # readme = \"README.md\"\n    # packages = [{include = \"hello_world\", from = \"src\"}]\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef read_text(\n    self,\n    member: StrPath | ArchiveMember,\n    *,\n    encoding: str = \"utf-8\",\n    errors: ErrorHandler = \"strict\",\n) -&gt; str:\n    \"\"\"\n    Read the member in text mode.\n\n    Parameters\n    ----------\n    member : StrPath | ArchiveMember\n        Name of the member or an ArchiveMember object.\n    encoding : str, optional\n        Encoding used to read the file. Default is `utf-8`.\n    errors : ErrorHandler, optional\n        String that specifies how encoding and decoding errors are to be handled.\n\n    Returns\n    -------\n    str\n        The contents of the file as a string.\n\n    Raises\n    ------\n    KeyError\n        Raised if the member is not found in the archive.\n\n    References\n    ----------\n    - [Standard Encodings](https://docs.python.org/3/library/codecs.html#standard-encodings)\n    - [Error Handlers](https://docs.python.org/3/library/codecs.html#error-handlers)\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.zip\") as archive:\n        text = archive.read_text(\"hello-world/pyproject.toml\")\n        print(text)\n        # [tool.poetry]\n        # name = \"hello-world\"\n        # version = \"0.1.0\"\n        # description = \"\"\n        # readme = \"README.md\"\n        # packages = [{include = \"hello_world\", from = \"src\"}]\n    ```\n    \"\"\"\n    return self._adapter.read_text(member, encoding=encoding, errors=errors)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.write","title":"write","text":"<pre><code>write(file: StrPath, *, arcname: StrPath | None = None) -&gt; None\n</code></pre> <p>Write a single file to the archive.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>StrPath</code> <p>Path of the file.</p> required <code>arcname</code> <code>StrPath</code> <p>Name which the file will have in the archive. Default is the basename of the file.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"example.zip\", \"w\") as archive:\n    archive.write(\"/root/some/path/to/foo.txt\")\n    archive.write(\"bar.txt\", arcname=\"baz.txt\")\n    archive.write(\"recipe/spam.txt\", arcname=\"ingredients/spam.txt\")\n    archive.write(\"recipe/eggs.txt\", arcname=\"ingredients/eggs.txt\")\n    archive.print_tree()\n    # example.zip\n    # \u251c\u2500\u2500 foo.txt\n    # \u251c\u2500\u2500 baz.txt\n    # \u2514\u2500\u2500 ingredients\n    #     \u251c\u2500\u2500 spam.txt\n    #     \u2514\u2500\u2500 eggs.txt\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef write(\n    self,\n    file: StrPath,\n    *,\n    arcname: StrPath | None = None,\n) -&gt; None:\n    \"\"\"\n    Write a single file to the archive.\n\n    Parameters\n    ----------\n    file : StrPath\n        Path of the file.\n    arcname : StrPath, optional\n        Name which the file will have in the archive.\n        Default is the basename of the file.\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"example.zip\", \"w\") as archive:\n        archive.write(\"/root/some/path/to/foo.txt\")\n        archive.write(\"bar.txt\", arcname=\"baz.txt\")\n        archive.write(\"recipe/spam.txt\", arcname=\"ingredients/spam.txt\")\n        archive.write(\"recipe/eggs.txt\", arcname=\"ingredients/eggs.txt\")\n        archive.print_tree()\n        # example.zip\n        # \u251c\u2500\u2500 foo.txt\n        # \u251c\u2500\u2500 baz.txt\n        # \u2514\u2500\u2500 ingredients\n        #     \u251c\u2500\u2500 spam.txt\n        #     \u2514\u2500\u2500 eggs.txt\n    ```\n    \"\"\"\n    self._adapter.write(file, arcname=arcname)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.write_bytes","title":"write_bytes","text":"<pre><code>write_bytes(data: bytes, *, arcname: StrPath) -&gt; None\n</code></pre> <p>Write the bytes <code>data</code> to a file within the archive named <code>arcname</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The bytes data to write to the archive.</p> required <code>arcname</code> <code>StrPath</code> <p>The name which the file will have in the archive.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"skynet.7z\", \"w\") as archive:\n    archive.write_bytes(b\"010010100101\", arcname=\"terminator.py\")\n    members = archive.get_names()\n    print(members)\n    # ('terminator.py',)\n    data = archive.read_bytes(\"terminator.py\")\n    print(data)\n    # b\"010010100101\"\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef write_bytes(\n    self,\n    data: bytes,\n    *,\n    arcname: StrPath,\n) -&gt; None:\n    \"\"\"\n    Write the bytes `data` to a file within the archive named `arcname`.\n\n    Parameters\n    ----------\n    data: str\n        The bytes data to write to the archive.\n    arcname : StrPath, optional\n        The name which the file will have in the archive.\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"skynet.7z\", \"w\") as archive:\n        archive.write_bytes(b\"010010100101\", arcname=\"terminator.py\")\n        members = archive.get_names()\n        print(members)\n        # ('terminator.py',)\n        data = archive.read_bytes(\"terminator.py\")\n        print(data)\n        # b\"010010100101\"\n    ```\n    \"\"\"\n    self._adapter.write_bytes(data, arcname=arcname)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.write_text","title":"write_text","text":"<pre><code>write_text(data: str, *, arcname: StrPath) -&gt; None\n</code></pre> <p>Write the string <code>data</code> to a file within the archive named <code>arcname</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The text data to write to the archive.</p> required <code>arcname</code> <code>StrPath</code> <p>The name which the file will have in the archive.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"newarchive.zip\", \"w\") as archive:\n    archive.write_text(\"spam and eggs\", arcname=\"recipe.txt\")\n    members = archive.get_names()\n    print(members)\n    # ('recipe.txt',)\n    text = archive.read_text(\"recipe.txt\")\n    print(text)\n    # 'spam and eggs'\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef write_text(\n    self,\n    data: str,\n    *,\n    arcname: StrPath,\n) -&gt; None:\n    \"\"\"\n    Write the string `data` to a file within the archive named `arcname`.\n\n    Parameters\n    ----------\n    data : str\n        The text data to write to the archive.\n    arcname : StrPath, optional\n        The name which the file will have in the archive.\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"newarchive.zip\", \"w\") as archive:\n        archive.write_text(\"spam and eggs\", arcname=\"recipe.txt\")\n        members = archive.get_names()\n        print(members)\n        # ('recipe.txt',)\n        text = archive.read_text(\"recipe.txt\")\n        print(text)\n        # 'spam and eggs'\n    ```\n    \"\"\"\n    self._adapter.write_text(data, arcname=arcname)\n</code></pre>"},{"location":"api-reference/archivefile/#archivefile.ArchiveFile.writeall","title":"writeall","text":"<pre><code>writeall(dir: StrPath, *, root: StrPath | None = None, glob: str = '*', recursive: bool = True) -&gt; None\n</code></pre> <p>Write a directory to the archive.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>StrPath</code> <p>Path of the directory.</p> required <code>root</code> <code>StrPath</code> <p>Directory that will be the root directory of the archive, all paths in the archive will be relative to it. This must be relative to given directory path. Default is the parent of the given directory.</p> <code>None</code> <code>glob</code> <code>str</code> <p>Only write files that match this glob pattern to the archive.</p> <code>'*'</code> <code>recursive</code> <code>bool</code> <p>Recursively write all the files in the given directory. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>from archivefile import ArchiveFile\n\nwith ArchiveFile(\"source.tar.gz\", \"w:gz\") as archive:\n    archive.writeall(dir=\"hello-world/\")\n    archive.print_tree()\n    # source.tar.gz\n    # \u2514\u2500\u2500 hello-world\n    #     \u251c\u2500\u2500 pyproject.toml\n    #     \u251c\u2500\u2500 README.md\n    #     \u251c\u2500\u2500 src\n    #     \u2502   \u2514\u2500\u2500 hello_world\n    #     \u2502       \u2514\u2500\u2500 __init__.py\n    #     \u2514\u2500\u2500 tests\n    #         \u2514\u2500\u2500 __init__.py\n</code></pre> Source code in <code>src/archivefile/_core.py</code> <pre><code>@validate_call\ndef writeall(\n    self,\n    dir: StrPath,\n    *,\n    root: StrPath | None = None,\n    glob: str = \"*\",\n    recursive: bool = True,\n) -&gt; None:\n    \"\"\"\n    Write a directory to the archive.\n\n    Parameters\n    ----------\n    dir : StrPath\n        Path of the directory.\n    root : StrPath\n        Directory that will be the root directory of the archive, all paths in the archive will be relative to it.\n        This must be relative to given directory path. Default is the parent of the given directory.\n    glob : str, optional\n        Only write files that match this glob pattern to the archive.\n    recursive : bool, optional\n        Recursively write all the files in the given directory. Default is True.\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    ```py\n    from archivefile import ArchiveFile\n\n    with ArchiveFile(\"source.tar.gz\", \"w:gz\") as archive:\n        archive.writeall(dir=\"hello-world/\")\n        archive.print_tree()\n        # source.tar.gz\n        # \u2514\u2500\u2500 hello-world\n        #     \u251c\u2500\u2500 pyproject.toml\n        #     \u251c\u2500\u2500 README.md\n        #     \u251c\u2500\u2500 src\n        #     \u2502   \u2514\u2500\u2500 hello_world\n        #     \u2502       \u2514\u2500\u2500 __init__.py\n        #     \u2514\u2500\u2500 tests\n        #         \u2514\u2500\u2500 __init__.py\n    ```\n    \"\"\"\n\n    self._adapter.writeall(\n        dir,\n        root=root,\n        glob=glob,\n        recursive=recursive,\n    )\n</code></pre>"},{"location":"api-reference/enums/","title":"Enums","text":""},{"location":"api-reference/enums/#archivefile.CompressionType","title":"CompressionType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Compression algorithms for ZipFile</p>"},{"location":"api-reference/enums/#archivefile.CompressionType.BZIP2","title":"BZIP2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BZIP2 = 12\n</code></pre> <p>The numeric constant for the BZIP2 compression method.  This requires the bz2 module.</p>"},{"location":"api-reference/enums/#archivefile.CompressionType.DEFLATED","title":"DEFLATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFLATED = 8\n</code></pre> <p>The numeric constant for the usual ZIP compression method.  This requires the zlib module.</p>"},{"location":"api-reference/enums/#archivefile.CompressionType.LZMA","title":"LZMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LZMA = 14\n</code></pre> <p>The numeric constant for the LZMA compression method.  This requires the lzma module.</p>"},{"location":"api-reference/enums/#archivefile.CompressionType.STORED","title":"STORED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STORED = 0\n</code></pre> <p>The numeric constant for an uncompressed archive member.</p>"},{"location":"api-reference/enums/#archivefile.CompressionType.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(key: str | int | None = None, default: Literal['stored', 'deflated', 'bzip2', 'lzma'] | str | int = 'stored') -&gt; CompressionType\n</code></pre> <p>Get the <code>CompressionType</code> by its name or number. Return the default if the key is missing or invalid.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | int</code> <p>The key to retrieve.</p> <code>None</code> <code>default</code> <code>Literal['stored', 'deflated', 'bzip2', 'lzma'] | str | int</code> <p>The default value to return if the key is missing or invalid.</p> <code>'stored'</code> <p>Returns:</p> Type Description <code>CompressionType</code> <p>The <code>CompressionType</code> corresponding to the key.</p> Source code in <code>src/archivefile/_enums.py</code> <pre><code>@classmethod\ndef get(\n    cls,\n    key: str | int | None = None,\n    default: Literal[\"stored\", \"deflated\", \"bzip2\", \"lzma\"] | str | int = \"stored\",\n) -&gt; CompressionType:\n    \"\"\"\n    Get the `CompressionType` by its name or number.\n    Return the default if the key is missing or invalid.\n\n    Parameters\n    ----------\n    key : str | int, optional\n        The key to retrieve.\n    default : Literal[\"stored\", \"deflated\", \"bzip2\", \"lzma\"] | str | int, optional\n        The default value to return if the key is missing or invalid.\n\n    Returns\n    -------\n    CompressionType\n        The `CompressionType` corresponding to the key.\n    \"\"\"\n    try:\n        match key:\n            case str():\n                return cls[key.upper()]\n\n            case int():\n                return cls(key)\n\n            case _:\n                return cls[default.upper()] if isinstance(default, str) else cls(default)\n    except (KeyError, ValueError):\n        return cls[default.upper()] if isinstance(default, str) else cls(default)\n</code></pre>"},{"location":"api-reference/models/","title":"Models","text":""},{"location":"api-reference/models/#archivefile._models.ArchiveMember","title":"ArchiveMember","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a member of an archive file. This is immutable, hashable, and supports equality checking.</p>"},{"location":"api-reference/models/#archivefile._models.ArchiveMember.checksum","title":"checksum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checksum: int = 0\n</code></pre> <p>CRC32 checksum if the archive is a ZipFile, RarFile, or SevenZipFile. Header checksum if archive is a TarFile.</p>"},{"location":"api-reference/models/#archivefile._models.ArchiveMember.compressed_size","title":"compressed_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compressed_size: ByteSize = ByteSize(0)\n</code></pre> <p>Compressed size of the archive member.</p>"},{"location":"api-reference/models/#archivefile._models.ArchiveMember.datetime","title":"datetime  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>datetime: UTCDateTime = min\n</code></pre> <p>The time and date of the last modification to the archive member.</p>"},{"location":"api-reference/models/#archivefile._models.ArchiveMember.is_dir","title":"is_dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_dir: bool = False\n</code></pre> <p>True if the archive member is a directory, False otherwise.</p>"},{"location":"api-reference/models/#archivefile._models.ArchiveMember.is_file","title":"is_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_file: bool = False\n</code></pre> <p>True if the archive member is a file, False otherwise.</p>"},{"location":"api-reference/models/#archivefile._models.ArchiveMember.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the archive member.</p>"},{"location":"api-reference/models/#archivefile._models.ArchiveMember.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: ByteSize = ByteSize(0)\n</code></pre> <p>Uncompressed size of the archive member.</p>"},{"location":"api-reference/types/","title":"Types","text":""},{"location":"api-reference/types/#archivefile._types.UTCDateTime","title":"UTCDateTime  <code>module-attribute</code>","text":"<pre><code>UTCDateTime = Annotated[datetime, AfterValidator(lambda dt: astimezone(utc))]\n</code></pre> <p>Datetime that's always in UTC.</p>"},{"location":"api-reference/types/#archivefile._types.StrPath","title":"StrPath  <code>module-attribute</code>","text":"<pre><code>StrPath: TypeAlias = Union[str, Path]\n</code></pre>"},{"location":"api-reference/types/#archivefile._types.CollectionOf","title":"CollectionOf  <code>module-attribute</code>","text":"<pre><code>CollectionOf: TypeAlias = Union[list[T], tuple[T, ...], set[T]]\n</code></pre> <p>Type alias representing a union of list, tuple, and set.</p>"},{"location":"api-reference/types/#archivefile._types.OpenArchiveMode","title":"OpenArchiveMode  <code>module-attribute</code>","text":"<pre><code>OpenArchiveMode: TypeAlias = Literal['r', 'r:*', 'r:', 'r:gz', 'r:bz2', 'r:xz', 'w', 'w:', 'w:gz', 'w:bz2', 'w:xz', 'x', 'x:', 'x:', 'x:gz', 'x:bz2', 'x:xz', 'a', 'a:']\n</code></pre>"},{"location":"api-reference/types/#archivefile._types.TreeStyle","title":"TreeStyle  <code>module-attribute</code>","text":"<pre><code>TreeStyle: TypeAlias = Literal['ansi', 'ascii', 'const', 'const_bold', 'rounded', 'double']\n</code></pre>"},{"location":"api-reference/types/#archivefile._types.TableStyle","title":"TableStyle  <code>module-attribute</code>","text":"<pre><code>TableStyle: TypeAlias = Literal['ascii', 'ascii2', 'ascii_double_head', 'square', 'square_double_head', 'minimal', 'minimal_heavy_head', 'minimal_double_head', 'simple', 'simple_head', 'simple_heavy', 'horizontals', 'rounded', 'heavy', 'heavy_edge', 'heavy_head', 'double', 'double_edge', 'markdown']\n</code></pre>"},{"location":"api-reference/types/#archivefile._types.SortBy","title":"SortBy  <code>module-attribute</code>","text":"<pre><code>SortBy: TypeAlias = Literal['name', 'datetime', 'size', 'compressed_size', 'checksum']\n</code></pre>"},{"location":"api-reference/types/#archivefile._types.ErrorHandler","title":"ErrorHandler  <code>module-attribute</code>","text":"<pre><code>ErrorHandler: TypeAlias = Literal['strict', 'ignore', 'replace', 'backslashreplace', 'surrogateescape', 'xmlcharrefreplace', 'namereplace']\n</code></pre>"},{"location":"api-reference/types/#archivefile._types.CompressionLevel","title":"CompressionLevel  <code>module-attribute</code>","text":"<pre><code>CompressionLevel: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>"},{"location":"api-reference/utils/","title":"Utils","text":""},{"location":"api-reference/utils/#archivefile.is_archive","title":"is_archive","text":"<pre><code>is_archive(file: StrPath) -&gt; bool\n</code></pre> <p>Check whether the given archive file is a supported archive or not.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>StrPath</code> <p>Path to the archive file.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the archive is supported, False otherwise.</p> Source code in <code>src/archivefile/_utils.py</code> <pre><code>def is_archive(file: StrPath) -&gt; bool:\n    \"\"\"\n    Check whether the given archive file is a supported archive or not.\n\n    Parameters\n    ---------\n    file : StrPath\n        Path to the archive file.\n\n    Returns\n    -------\n    bool\n        True if the archive is supported, False otherwise.\n    \"\"\"\n    file = realpath(file)\n\n    if file.exists():\n        return is_tarfile(file) or is_zipfile(file) or is_rarfile(file) or is_rarfile_sfx(file) or is_7zfile(file)\n    else:\n        return False\n</code></pre>"}]}